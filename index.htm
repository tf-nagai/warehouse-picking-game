<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂÄâÂ∫´„Éî„ÉÉ„Ç≠„É≥„Ç∞„Ç≤„Éº„É†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            min-height: 100dvh;
            font-family: 'Segoe UI', 'Hiragino Sans', sans-serif;
            overflow: hidden;
            touch-action: none;
            padding: 5px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            width: 100%;
            height: 100%;
        }
        
        h1 {
            color: #ffd700;
            font-size: clamp(14px, 3vw, 24px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #gameCanvas {
            border: 3px solid #ffd700;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            cursor: pointer;
            outline: none;
            max-width: 100%;
            max-height: 60vh;
            width: auto;
            height: auto;
        }
        
        @media (min-width: 1024px) and (hover: hover) {
            #gameCanvas {
                max-height: 85vh;
            }
        }
        
        .controls {
            color: #ccc;
            font-size: clamp(10px, 1.5vw, 14px);
            text-align: center;
            padding: 5px;
        }
        
        .controls span {
            color: #ffd700;
            font-weight: bold;
        }

        .virtual-controls {
            display: none;
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            padding: 0 15px;
            z-index: 100;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }
        
        .dpad {
            position: relative;
            width: min(35vw, 200px);
            height: min(35vw, 200px);
        }
        
        .dpad-btn {
            position: absolute;
            width: 32%;
            height: 32%;
            background: rgba(255, 215, 0, 0.9);
            border: 3px solid #ffd700;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(18px, 5vw, 32px);
            color: #1a1a2e;
            font-weight: bold;
            touch-action: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .dpad-btn:active, .dpad-btn.active {
            background: #ffd700;
            transform: scale(0.95);
        }
        
        .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        .dpad-up:active, .dpad-up.active { transform: translateX(-50%) scale(0.95); }
        .dpad-down:active, .dpad-down.active { transform: translateX(-50%) scale(0.95); }
        .dpad-left:active, .dpad-left.active { transform: translateY(-50%) scale(0.95); }
        .dpad-right:active, .dpad-right.active { transform: translateY(-50%) scale(0.95); }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .action-btn {
            width: min(28vw, 140px);
            height: min(28vw, 140px);
            background: linear-gradient(145deg, #4CAF50, #2E7D32);
            border: 4px solid #81C784;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(14px, 4vw, 24px);
            color: #fff;
            font-weight: bold;
            text-align: center;
            touch-action: none;
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5);
        }
        
        .action-btn:active, .action-btn.active {
            transform: scale(0.95);
        }
        
        .urgent-btns {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            gap: clamp(10px, 3vw, 30px);
            z-index: 200;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }
        
        .urgent-choice-btn {
            padding: clamp(12px, 3vw, 20px) clamp(20px, 5vw, 35px);
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            touch-action: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .accept-btn {
            background: linear-gradient(145deg, #FF5252, #D32F2F);
            color: white;
            border: 3px solid #FF8A80;
        }
        
        .reject-btn {
            background: linear-gradient(145deg, #666, #444);
            color: white;
            border: 3px solid #888;
        }
        
        .start-btn {
            position: fixed;
            bottom: calc(min(35vw, 200px) + 30px);
            left: 50%;
            transform: translateX(-50%);
            padding: clamp(12px, 3vw, 20px) clamp(25px, 6vw, 50px);
            background: #ffd700;
            border: none;
            border-radius: 15px;
            font-size: clamp(16px, 3vw, 24px);
            font-weight: bold;
            color: #1a1a2e;
            display: none;
            touch-action: none;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            z-index: 150;
        }
        
        .sound-toggle {
            position: fixed;
            top: 8px;
            right: 8px;
            padding: clamp(4px, 1vw, 8px) clamp(6px, 1.5vw, 12px);
            background: rgba(255, 215, 0, 0.8);
            border: none;
            border-radius: 8px;
            font-size: clamp(14px, 2vw, 18px);
            cursor: pointer;
            z-index: 100;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .virtual-controls, .start-btn {
                display: flex;
            }
            .controls {
                display: none;
            }
            #gameCanvas {
                max-height: calc(100dvh - min(35vw, 200px) - 80px);
            }
        }
        
        @media (hover: hover) and (pointer: fine) {
            .virtual-controls, .start-btn {
                display: none !important;
            }
            .controls {
                display: block;
            }
            #gameCanvas {
                max-height: 85vh;
            }
            body {
                padding-top: 10px;
            }
        }
        
        @media (max-height: 500px) and (hover: none) {
            h1 {
                display: none;
            }
            body {
                padding: 2px;
            }
            #gameCanvas {
                max-height: calc(100dvh - min(25vw, 120px) - 20px);
            }
            .dpad {
                width: min(22vw, 120px);
                height: min(22vw, 120px);
            }
            .action-btn {
                width: min(18vw, 100px);
                height: min(18vw, 100px);
            }
            .start-btn {
                bottom: calc(min(22vw, 120px) + 15px);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üè≠ ÂÄâÂ∫´„Éî„ÉÉ„Ç≠„É≥„Ç∞„Ç≤„Éº„É†</h1>
        <canvas id="gameCanvas" tabindex="0"></canvas>
        <div class="controls">
            <span>‚Üë‚Üì‚Üê‚Üí/WASD</span>ÁßªÂãï | <span>SPACE</span>„Éî„ÉÉ„ÇØ/Á¥çÂìÅ | <span>M</span>BGM | Á∑äÊÄ•ÊôÇ<span>Y/N</span>„ÅßÈÅ∏Êäû
        </div>
    </div>
    
    <button class="sound-toggle" id="soundToggle">üîä</button>
    <button class="start-btn" id="startBtn">üéÆ „Çπ„Çø„Éº„Éà</button>
    
    <div class="urgent-btns" id="urgentBtns">
        <button class="urgent-choice-btn accept-btn" id="acceptBtn">üö® Á∑äÊÄ•„ÇíÂèó„Åë„Çã</button>
        <button class="urgent-choice-btn reject-btn" id="rejectBtn">Á∂öË°å„Åô„Çã</button>
    </div>
    
    <div class="virtual-controls" id="virtualControls">
        <div class="control-row">
            <div class="dpad">
                <div class="dpad-btn dpad-up" data-dir="up">‚ñ≤</div>
                <div class="dpad-btn dpad-down" data-dir="down">‚ñº</div>
                <div class="dpad-btn dpad-left" data-dir="left">‚óÄ</div>
                <div class="dpad-btn dpad-right" data-dir="right">‚ñ∂</div>
            </div>
            <div class="action-buttons">
                <div class="action-btn" id="actionBtn">üì¶<br>„Éî„ÉÉ„ÇØ</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const soundToggle = document.getElementById('soundToggle');
        const actionBtn = document.getElementById('actionBtn');
        const urgentBtns = document.getElementById('urgentBtns');
        const acceptBtn = document.getElementById('acceptBtn');
        const rejectBtn = document.getElementById('rejectBtn');

        const SCREEN_WIDTH = 1200;
        const SCREEN_HEIGHT = 750;
        const MAP_WIDTH = 2200;
        const MAP_HEIGHT = 1800;
        
        const dpr = window.devicePixelRatio || 1;
        canvas.width = SCREEN_WIDTH * dpr;
        canvas.height = SCREEN_HEIGHT * dpr;
        ctx.scale(dpr, dpr);
        
        function resizeCanvas() {
            const aspectRatio = SCREEN_WIDTH / SCREEN_HEIGHT;
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const controlHeight = isTouchDevice ? Math.min(window.innerWidth * 0.35, 200) + 50 : 0;
            const maxWidth = window.innerWidth - 20;
            const maxHeight = window.innerHeight - controlHeight - 60;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

        const GAME_STATE = { TITLE: 0, PLAYING: 1, GAMEOVER: 2, URGENT_CHOICE: 3 };
        const ORDER_TYPE = { NORMAL: 0, URGENT: 1 };

        const ITEM_TYPES = [
            { name: 'Â∏ΩÂ≠ê', emoji: 'üß¢', color: '#FF6B6B' },
            { name: '„Ç∑„É£„ÉÑ', emoji: 'üëî', color: '#4ECDC4' },
            { name: '„Ç∫„Éú„É≥', emoji: 'üëñ', color: '#45B7D1' },
            { name: 'Èù¥', emoji: 'üëü', color: '#96CEB4' },
            { name: 'Èù¥‰∏ã', emoji: 'üß¶', color: '#FFEAA7' },
            { name: 'ÂÇò', emoji: 'üåÇ', color: '#DDA0DD' },
            { name: '„Ç´„Éê„É≥', emoji: 'üëú', color: '#F0E68C' }
        ];

        let game = {
            state: GAME_STATE.TITLE,
            score: 0,
            timeLeft: 60,
            level: 1,
            cameraX: 0,
            cameraY: 0,
            shelves: [],
            forklifts: [],
            shippingStation: null,
            currentOrder: null,
            pendingUrgent: null,
            completedOrders: 0,
            urgentCompleted: 0,
            urgentMissed: 0,
            hitCooldown: 0,
            lastTime: 0,
            nextUrgentTime: 0,
            eventLog: [],
            flashEffect: null,
            telopText: null,
            telopTimer: 0
        };

        let player = {
            x: 400,
            y: 400,
            width: 48,
            height: 58,
            speed: 4.5,
            inventory: [],
            direction: 'down'
        };

        const keys = {};
        const touchDirs = { up: false, down: false, left: false, right: false };

        let audioCtx = null;
        let bgmPlaying = false;
        let bgmOsc = null;
        let bgmGain = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            switch(type) {
                case 'pick':
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'ship':
                    osc.frequency.setValueAtTime(523, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'urgent':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.15);
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'urgentAccept':
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.25);
                    break;
            }
        }

        function startBGM() {
            if (!audioCtx || bgmPlaying) return;
            bgmOsc = audioCtx.createOscillator();
            bgmGain = audioCtx.createGain();
            bgmOsc.connect(bgmGain);
            bgmGain.connect(audioCtx.destination);
            bgmOsc.type = 'triangle';
            bgmOsc.frequency.setValueAtTime(220, audioCtx.currentTime);
            bgmGain.gain.setValueAtTime(0.03, audioCtx.currentTime);
            bgmOsc.start();
            bgmPlaying = true;
            
            const notes = [220, 262, 294, 330, 349, 392, 440];
            let noteIndex = 0;
            setInterval(() => {
                if (bgmPlaying && bgmOsc) {
                    bgmOsc.frequency.setValueAtTime(notes[noteIndex], audioCtx.currentTime);
                    noteIndex = (noteIndex + 1) % notes.length;
                }
            }, 400);
        }

        function stopBGM() {
            if (bgmOsc) {
                bgmOsc.stop();
                bgmOsc = null;
                bgmPlaying = false;
            }
        }

        function toggleBGM() {
            if (bgmPlaying) {
                stopBGM();
                soundToggle.textContent = 'üîá';
            } else {
                startBGM();
                soundToggle.textContent = 'üîä';
            }
        }

        function generateMap() {
            game.shelves = [];
            game.forklifts = [];

            const shelfWidth = 115;
            const shelfHeight = 85;
            const gapX = 310;
            const gapY = 270;
            const startX = 180;
            const startY = 200;

            const rows = 5;
            const cols = 6;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = startX + col * gapX;
                    const y = startY + row * gapY;
                    const typeIndex = (row * cols + col) % ITEM_TYPES.length;
                    
                    game.shelves.push({
                        x, y,
                        width: shelfWidth,
                        height: shelfHeight,
                        itemType: typeIndex,
                        stock: 99
                    });
                }
            }

            game.shippingStation = {
                x: MAP_WIDTH / 2 - 100,
                y: MAP_HEIGHT - 140,
                width: 200,
                height: 100
            };

            createForklifts();
        }

        function createForklifts() {
            game.forklifts = [];
            const forkliftCount = Math.min(2 + Math.floor(game.level / 2), 8);
            
            const routes = [
                { startX: 100, startY: 340, endX: MAP_WIDTH - 150, endY: 340, dir: 'h' },
                { startX: 100, startY: 610, endX: MAP_WIDTH - 150, endY: 610, dir: 'h' },
                { startX: 100, startY: 880, endX: MAP_WIDTH - 150, endY: 880, dir: 'h' },
                { startX: 100, startY: 1150, endX: MAP_WIDTH - 150, endY: 1150, dir: 'h' },
                { startX: 100, startY: 1420, endX: MAP_WIDTH - 150, endY: 1420, dir: 'h' },
                { startX: 420, startY: 150, endX: 420, endY: MAP_HEIGHT - 200, dir: 'v' },
                { startX: 930, startY: 150, endX: 930, endY: MAP_HEIGHT - 200, dir: 'v' },
                { startX: 1440, startY: 150, endX: 1440, endY: MAP_HEIGHT - 200, dir: 'v' },
                { startX: 1950, startY: 150, endX: 1950, endY: MAP_HEIGHT - 200, dir: 'v' }
            ];

            for (let i = 0; i < forkliftCount; i++) {
                const route = routes[i % routes.length];
                const baseSpeed = 2.0 + game.level * 0.2;
                game.forklifts.push({
                    x: route.dir === 'h' ? route.startX + Math.random() * 400 : route.startX,
                    y: route.dir === 'v' ? route.startY + Math.random() * 400 : route.startY,
                    width: 50,
                    height: 70,
                    speed: baseSpeed + Math.random() * 0.5,
                    direction: Math.random() < 0.5 ? 1 : -1,
                    route
                });
            }
        }

        function createOrder(type) {
            const itemCount = type === ORDER_TYPE.URGENT ? 
                Math.min(2 + Math.floor(game.level / 3), 3) :
                Math.min(2 + Math.floor(game.level / 2), 5);
            
            const items = [];
            const usedTypes = new Set();
            
            for (let i = 0; i < itemCount; i++) {
                let typeIndex;
                do {
                    typeIndex = Math.floor(Math.random() * ITEM_TYPES.length);
                } while (usedTypes.has(typeIndex));
                usedTypes.add(typeIndex);
                
                items.push({
                    type: typeIndex,
                    required: type === ORDER_TYPE.URGENT ? 1 : Math.min(1 + Math.floor(game.level / 3), 3),
                    collected: 0
                });
            }

            const baseTime = type === ORDER_TYPE.URGENT ? 25 : 35;
            const timeLimit = baseTime + itemCount * 8 - game.level * 0.5;

            return {
                type,
                items,
                timeLimit: Math.max(timeLimit, 15),
                timeRemaining: Math.max(timeLimit, 15),
                bonus: type === ORDER_TYPE.URGENT ? 500 : 200,
                readyToShip: false,
                deadline: type === ORDER_TYPE.URGENT ? 12 : null
            };
        }

        function addEventLog(text, type = 'info') {
            game.eventLog.unshift({ text, type, time: 3 });
            if (game.eventLog.length > 5) game.eventLog.pop();
        }

        function triggerFlash(color, duration) {
            game.flashEffect = { color, duration, timer: duration };
        }

        function showTelop(text, duration) {
            game.telopText = text;
            game.telopTimer = duration;
        }

        function resetUrgentTimer() {
            game.nextUrgentTime = 20 + Math.random() * 25;
        }

        function assignNewOrder() {
            game.currentOrder = createOrder(ORDER_TYPE.NORMAL);
            player.inventory = [];
            addEventLog('üìã Êñ∞Ë¶è„Ç™„Éº„ÉÄ„ÉºÂèó‰ªò', 'info');
        }

        function triggerUrgentOrder() {
            game.pendingUrgent = createOrder(ORDER_TYPE.URGENT);
            game.state = GAME_STATE.URGENT_CHOICE;
            playSound('urgent');
            triggerFlash('rgba(255, 0, 0, 0.4)', 0.5);
            showTelop('üö® Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÂâ≤„ÇäËæº„ÅøÔºÅ', 1);
            addEventLog('üö® Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÁô∫ÁîüÔºÅ', 'urgent');
            urgentBtns.style.display = 'flex';
        }

        function acceptUrgent() {
            addEventLog('‚ö° Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÂèóË´æÔºÅ', 'urgent');
            game.currentOrder = game.pendingUrgent;
            game.pendingUrgent = null;
            player.inventory = [];
            game.state = GAME_STATE.PLAYING;
            urgentBtns.style.display = 'none';
            playSound('urgentAccept');
            showTelop('üî¥ Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÈñãÂßãÔºÅ', 1.5);
            resetUrgentTimer();
        }

        function rejectUrgent() {
            addEventLog('‚ùå Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÊãíÂê¶ (-5Áßí)', 'warning');
            game.timeLeft = Math.max(0, game.timeLeft - 5);
            game.urgentMissed++;
            game.pendingUrgent = null;
            game.state = GAME_STATE.PLAYING;
            urgentBtns.style.display = 'none';
            triggerFlash('rgba(100, 100, 100, 0.5)', 0.3);
            resetUrgentTimer();
        }

        function findNearShelf() {
            const px = player.x + player.width / 2;
            const py = player.y + player.height / 2;
            
            for (let shelf of game.shelves) {
                const sx = shelf.x + shelf.width / 2;
                const sy = shelf.y + shelf.height / 2;
                const dist = Math.sqrt((px - sx) ** 2 + (py - sy) ** 2);
                if (dist < 95) return shelf;
            }
            return null;
        }

        function isNearShippingStation() {
            const px = player.x + player.width / 2;
            const py = player.y + player.height / 2;
            const s = game.shippingStation;
            const sx = s.x + s.width / 2;
            const sy = s.y + s.height / 2;
            return Math.sqrt((px - sx) ** 2 + (py - sy) ** 2) < 120;
        }

        function tryPick() {
            const order = game.currentOrder;
            if (!order) return;

            if (order.readyToShip && isNearShippingStation()) {
                const timeBonus = Math.floor(order.timeRemaining * 10);
                const basePoints = order.bonus * order.items.length;
                const urgentMultiplier = order.type === ORDER_TYPE.URGENT ? 2 : 1;
                const totalPoints = (basePoints + timeBonus) * urgentMultiplier;
                
                game.score += totalPoints;
                game.completedOrders++;
                if (order.type === ORDER_TYPE.URGENT) {
                    game.urgentCompleted++;
                    game.timeLeft = Math.min(game.timeLeft + 10, 90);
                    addEventLog(`üéâ Á∑äÊÄ•ÂÆå‰∫ÜÔºÅ+${totalPoints}ÁÇπ +10Áßí`, 'success');
                    showTelop(`üéâ Á∑äÊÄ•ÂÆå‰∫ÜÔºÅ+${totalPoints}ÁÇπÔºÅ`, 2);
                } else {
                    addEventLog(`‚úÖ Âá∫Ëç∑ÂÆå‰∫ÜÔºÅ+${totalPoints}ÁÇπ`, 'success');
                    showTelop(`‚úÖ Âá∫Ëç∑ÂÆå‰∫ÜÔºÅ+${totalPoints}ÁÇπ`, 1.5);
                }
                
                triggerFlash('rgba(0, 255, 0, 0.3)', 0.3);
                playSound('ship');
                
                if (game.completedOrders % 3 === 0) {
                    game.level++;
                    addEventLog(`üìà „É¨„Éô„É´${game.level}ÔºÅ`, 'info');
                    createForklifts();
                }
                
                assignNewOrder();
                return;
            }

            const shelf = findNearShelf();
            if (shelf && !order.readyToShip) {
                const orderItem = order.items.find(item => 
                    item.type === shelf.itemType && item.collected < item.required);
                
                if (orderItem && shelf.stock > 0) {
                    orderItem.collected++;
                    player.inventory.push(shelf.itemType);
                    playSound('pick');
                    addEventLog(`üì¶ ${ITEM_TYPES[shelf.itemType].emoji} „Éî„ÉÉ„ÇØÔºÅ`, 'info');
                    
                    const allCollected = order.items.every(item => item.collected >= item.required);
                    if (allCollected) {
                        order.readyToShip = true;
                        addEventLog('üöö Âá∫Ëç∑Ê∫ñÂÇôÂÆå‰∫ÜÔºÅÂá∫Ëç∑Âè£„Å∏ÔºÅ', 'success');
                        showTelop('üöö Âá∫Ëç∑Âè£„Å∏Âêë„Åã„ÅàÔºÅ', 1.5);
                    }
                }
            }
        }

        function checkShelfCollision(x, y, w, h) {
            for (let shelf of game.shelves) {
                if (x < shelf.x + shelf.width &&
                    x + w > shelf.x &&
                    y < shelf.y + shelf.height &&
                    y + h > shelf.y) {
                    return true;
                }
            }
            return false;
        }

        function checkForkliftCollision() {
            if (game.hitCooldown > 0) return;
            
            for (let fl of game.forklifts) {
                if (player.x < fl.x + fl.width &&
                    player.x + player.width > fl.x &&
                    player.y < fl.y + fl.height &&
                    player.y + player.height > fl.y) {
                    
                    game.hitCooldown = 2;
                    game.timeLeft = Math.max(0, game.timeLeft - 5);
                    playSound('hit');
                    triggerFlash('rgba(255, 0, 0, 0.5)', 0.3);
                    addEventLog('üí• „Éï„Ç©„Éº„ÇØ„É™„Éï„ÉàÊé•Ëß¶ÔºÅ-5Áßí', 'warning');
                    
                    const dx = player.x - fl.x;
                    const dy = player.y - fl.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    let pushX = player.x + (dx / dist) * 80;
                    let pushY = player.y + (dy / dist) * 80;
                    
                    pushX = Math.max(0, Math.min(MAP_WIDTH - player.width, pushX));
                    pushY = Math.max(0, Math.min(MAP_HEIGHT - player.height, pushY));
                    
                    if (!checkShelfCollision(pushX, pushY, player.width, player.height)) {
                        player.x = pushX;
                        player.y = pushY;
                    } else if (!checkShelfCollision(pushX, player.y, player.width, player.height)) {
                        player.x = pushX;
                    } else if (!checkShelfCollision(player.x, pushY, player.width, player.height)) {
                        player.y = pushY;
                    } else {
                        const offsets = [
                            {x: 80, y: 0}, {x: -80, y: 0}, {x: 0, y: 80}, {x: 0, y: -80},
                            {x: 60, y: 60}, {x: -60, y: 60}, {x: 60, y: -60}, {x: -60, y: -60}
                        ];
                        for (let off of offsets) {
                            const testX = Math.max(0, Math.min(MAP_WIDTH - player.width, player.x + off.x));
                            const testY = Math.max(0, Math.min(MAP_HEIGHT - player.height, player.y + off.y));
                            if (!checkShelfCollision(testX, testY, player.width, player.height)) {
                                player.x = testX;
                                player.y = testY;
                                break;
                            }
                        }
                    }
                    break;
                }
            }
        }

        function update(deltaTime) {
            if (game.state !== GAME_STATE.PLAYING && game.state !== GAME_STATE.URGENT_CHOICE) return;

            if (game.state === GAME_STATE.URGENT_CHOICE) {
                if (game.pendingUrgent) {
                    game.pendingUrgent.deadline -= deltaTime;
                    if (game.pendingUrgent.deadline <= 0) {
                        rejectUrgent();
                    }
                }
                return;
            }

            game.timeLeft -= deltaTime;
            if (game.timeLeft <= 0) {
                game.timeLeft = 0;
                game.state = GAME_STATE.GAMEOVER;
                urgentBtns.style.display = 'none';
                return;
            }

            if (game.hitCooldown > 0) game.hitCooldown -= deltaTime;

            game.nextUrgentTime -= deltaTime;
            if (game.nextUrgentTime <= 0 && game.currentOrder && !game.currentOrder.readyToShip) {
                triggerUrgentOrder();
            }

            if (game.currentOrder) {
                game.currentOrder.timeRemaining -= deltaTime;
                if (game.currentOrder.timeRemaining <= 0) {
                    addEventLog('‚è∞ „Ç™„Éº„ÉÄ„ÉºÊúüÈôêÂàá„ÇåÔºÅ-3Áßí', 'warning');
                    game.timeLeft = Math.max(0, game.timeLeft - 3);
                    triggerFlash('rgba(255, 100, 0, 0.4)', 0.3);
                    assignNewOrder();
                }
            }

            let dx = 0, dy = 0;
            if (keys['ArrowUp'] || keys['KeyW'] || touchDirs.up) dy = -1;
            if (keys['ArrowDown'] || keys['KeyS'] || touchDirs.down) dy = 1;
            if (keys['ArrowLeft'] || keys['KeyA'] || touchDirs.left) dx = -1;
            if (keys['ArrowRight'] || keys['KeyD'] || touchDirs.right) dx = 1;

            if (dx !== 0 || dy !== 0) {
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                if (dx > 0) player.direction = 'right';
                else if (dx < 0) player.direction = 'left';
                else if (dy > 0) player.direction = 'down';
                else if (dy < 0) player.direction = 'up';

                const newX = player.x + dx * player.speed;
                const newY = player.y + dy * player.speed;
                
                if (!checkShelfCollision(newX, player.y, player.width, player.height)) {
                    player.x = Math.max(0, Math.min(MAP_WIDTH - player.width, newX));
                }
                if (!checkShelfCollision(player.x, newY, player.width, player.height)) {
                    player.y = Math.max(0, Math.min(MAP_HEIGHT - player.height, newY));
                }
            }

            let targetX = player.x - SCREEN_WIDTH / 2 + player.width / 2;
            let targetY = player.y - SCREEN_HEIGHT / 2 + player.height / 2;
            targetX = Math.max(0, Math.min(MAP_WIDTH - SCREEN_WIDTH, targetX));
            targetY = Math.max(0, Math.min(MAP_HEIGHT - SCREEN_HEIGHT, targetY));
            game.cameraX += (targetX - game.cameraX) * 0.1;
            game.cameraY += (targetY - game.cameraY) * 0.1;

            game.forklifts.forEach(fl => {
                if (fl.route.dir === 'h') {
                    fl.x += fl.speed * fl.direction;
                    if (fl.x <= fl.route.startX || fl.x >= fl.route.endX - fl.width) {
                        fl.direction *= -1;
                    }
                } else {
                    fl.y += fl.speed * fl.direction;
                    if (fl.y <= fl.route.startY || fl.y >= fl.route.endY - fl.height) {
                        fl.direction *= -1;
                    }
                }
            });

            checkForkliftCollision();

            game.eventLog.forEach(e => e.time -= deltaTime);
            game.eventLog = game.eventLog.filter(e => e.time > 0);

            if (game.flashEffect) {
                game.flashEffect.timer -= deltaTime;
                if (game.flashEffect.timer <= 0) game.flashEffect = null;
            }
            if (game.telopTimer > 0) {
                game.telopTimer -= deltaTime;
                if (game.telopTimer <= 0) game.telopText = null;
            }
        }

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                canvas.focus();
                initAudio();
                if (game.state === GAME_STATE.PLAYING) {
                    tryPick();
                } else if (game.state === GAME_STATE.TITLE || game.state === GAME_STATE.GAMEOVER) {
                    startGame();
                }
                e.preventDefault();
            }
            
            if (game.state === GAME_STATE.URGENT_CHOICE) {
                if (e.code === 'KeyY') {
                    acceptUrgent();
                    e.preventDefault();
                } else if (e.code === 'KeyN') {
                    rejectUrgent();
                    e.preventDefault();
                }
            }
            
            if (e.code === 'KeyM') toggleBGM();
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        document.querySelectorAll('.dpad-btn').forEach(btn => {
            const dir = btn.dataset.dir;
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchDirs[dir] = true;
                btn.classList.add('active');
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchDirs[dir] = false;
                btn.classList.remove('active');
            });
            btn.addEventListener('touchcancel', () => {
                touchDirs[dir] = false;
                btn.classList.remove('active');
            });
        });

        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            if (game.state === GAME_STATE.PLAYING) tryPick();
            actionBtn.classList.add('active');
        });
        actionBtn.addEventListener('touchend', () => actionBtn.classList.remove('active'));

        acceptBtn.addEventListener('click', () => { if (game.state === GAME_STATE.URGENT_CHOICE) acceptUrgent(); });
        rejectBtn.addEventListener('click', () => { if (game.state === GAME_STATE.URGENT_CHOICE) rejectUrgent(); });
        acceptBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (game.state === GAME_STATE.URGENT_CHOICE) acceptUrgent(); });
        rejectBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (game.state === GAME_STATE.URGENT_CHOICE) rejectUrgent(); });

        startBtn.addEventListener('click', () => { initAudio(); if (game.state !== GAME_STATE.PLAYING) startGame(); });
        startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); initAudio(); if (game.state !== GAME_STATE.PLAYING) startGame(); });
        soundToggle.addEventListener('click', () => { initAudio(); toggleBGM(); });
        canvas.addEventListener('click', () => canvas.focus());

        function startGame() {
            game.state = GAME_STATE.PLAYING;
            game.score = 0;
            game.timeLeft = 60;
            game.completedOrders = 0;
            game.urgentCompleted = 0;
            game.urgentMissed = 0;
            game.level = 1;
            game.hitCooldown = 0;
            game.eventLog = [];
            game.flashEffect = null;
            game.telopText = null;
            
            player.x = 400;
            player.y = 400;
            player.inventory = [];
            
            generateMap();
            assignNewOrder();
            resetUrgentTimer();
            
            game.cameraX = player.x - SCREEN_WIDTH / 2;
            game.cameraY = player.y - SCREEN_HEIGHT / 2;
            
            startBGM();
        }

        function draw() {
            ctx.fillStyle = '#f5f5dc';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            if (game.state === GAME_STATE.TITLE) {
                drawTitle();
            } else {
                drawGame();
                if (game.state === GAME_STATE.URGENT_CHOICE) {
                    drawUrgentChoice();
                }
                if (game.state === GAME_STATE.GAMEOVER) {
                    drawGameOver();
                }
            }
        }

        function drawTitle() {
            const gradient = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT);
            gradient.addColorStop(0, '#1a1a3e');
            gradient.addColorStop(1, '#2a2a5e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üè≠ ÂÄâÂ∫´„Éî„ÉÉ„Ç≠„É≥„Ç∞„Ç≤„Éº„É†', SCREEN_WIDTH/2, 80);

            const leftX = 50;
            const panelWidth = 520;
            
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(leftX, 110, panelWidth, 250);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(leftX, 110, panelWidth, 250);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('üìñ ÈÅä„Å≥Êñπ', leftX + 20, 145);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px sans-serif';
            const howToPlay = [
                '‚ë† „Ç™„Éº„ÉÄ„Éº„ÅÆÂïÜÂìÅ„ÇíÊ£ö„Åã„Çâ„Éî„ÉÉ„ÇØ',
                '‚ë° ÂÖ®ÈÉ®ÈõÜ„ÇÅ„Åü„ÇâÂá∫Ëç∑Âè£„Å∏ÈÅã„Å∂',
                '‚ë¢ Á∑†ÂàáÊôÇÈñìÂÜÖ„Å´Á¥çÂìÅ„ÅßÈ´òÂæóÁÇπÔºÅ'
            ];
            howToPlay.forEach((text, i) => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillText(text, leftX + 20, 185 + i * 35);
            });
            
            ctx.fillStyle = '#FF6B6B';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('üö® Á∑äÊÄ•„Ç™„Éº„ÉÄ„Éº', leftX + 20, 305);
            ctx.font = '16px sans-serif';
            ctx.fillStyle = '#ccc';
            ctx.fillText('YÔºöÂèó„Åë„Çã ‚Üí È´òÂæóÁÇπÔºÜÊôÇÈñì+10Áßí', leftX + 30, 330);
            ctx.fillText('NÔºöÁÑ°Ë¶ñ ‚Üí -5Áßí„Éö„Éä„É´„ÉÜ„Ç£', leftX + 30, 352);

            const rightX = 620;
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(rightX, 110, panelWidth, 250);
            ctx.strokeStyle = '#ffd700';
            ctx.strokeRect(rightX, 110, panelWidth, 250);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 22px sans-serif';
            ctx.fillText('üéÆ Êìç‰ΩúÊñπÊ≥ï', rightX + 20, 145);
            
            ctx.font = '18px sans-serif';
            const controls = [
                { key: '‚Üë‚Üì‚Üê‚Üí / WASD', action: 'ÁßªÂãï' },
                { key: 'SPACE', action: '„Éî„ÉÉ„ÇØ / Á¥çÂìÅ' },
                { key: 'Y / N', action: 'Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÈÅ∏Êäû' },
                { key: 'M', action: 'BGM ON/OFF' }
            ];
            controls.forEach((c, i) => {
                const y = 180 + i * 45;
                ctx.fillStyle = '#ffd700';
                ctx.fillText(c.key, rightX + 20, y);
                ctx.fillStyle = '#fff';
                ctx.fillText(c.action, rightX + 20, y + 20);
            });

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('„ÄêÂèñÊâ±ÂïÜÂìÅ„Äë', SCREEN_WIDTH/2, 400);
            
            ITEM_TYPES.forEach((item, i) => {
                const x = SCREEN_WIDTH/2 - 240 + i * 72;
                const y = 440;
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '28px sans-serif';
                ctx.fillText(item.emoji, x, y + 10);
            });

            ctx.fillStyle = '#FFA500';
            ctx.font = '16px sans-serif';
            ctx.fillText('‚ö†Ô∏è „Éï„Ç©„Éº„ÇØ„É™„Éï„ÉàÊé•Ëß¶: -5Áßí | „Ç™„Éº„ÉÄ„ÉºÊúüÈôêÂàá„Çå: -3Áßí', SCREEN_WIDTH/2, 510);

            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#ffd700';
            } else {
                ctx.fillStyle = '#aa9500';
            }
            ctx.font = 'bold 34px sans-serif';
            ctx.fillText('üéÆ SPACE / „Çø„ÉÉ„Éó „Åß„Çπ„Çø„Éº„Éà üéÆ', SCREEN_WIDTH/2, 600);
        }

        function drawGame() {
            ctx.save();
            ctx.translate(-game.cameraX, -game.cameraY);

            drawFloor();
            drawShippingStation();
            game.shelves.forEach(s => drawShelf(s));
            game.forklifts.forEach(f => drawForklift(f));
            drawPlayer();

            ctx.restore();

            drawUI();
            drawEventLog();
            drawTelop();
            drawFlashEffect();
            drawMinimap();
        }

        function drawFloor() {
            const tileSize = 120;
            for (let x = 0; x < MAP_WIDTH; x += tileSize) {
                for (let y = 0; y < MAP_HEIGHT; y += tileSize) {
                    ctx.fillStyle = (Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0 
                        ? '#e8e0c8' : '#ddd8c0';
                    ctx.fillRect(x, y, tileSize, tileSize);
                }
            }
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.setLineDash([25, 15]);
            for (let x = 310; x < MAP_WIDTH; x += 310) {
                ctx.beginPath();
                ctx.moveTo(x - 50, 120);
                ctx.lineTo(x - 50, MAP_HEIGHT - 180);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function drawShippingStation() {
            const s = game.shippingStation;
            
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(s.x + 6, s.y + 6, s.width, s.height);
            
            ctx.fillStyle = '#2E7D32';
            ctx.fillRect(s.x, s.y, s.width, s.height);
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 5;
            ctx.strokeRect(s.x, s.y, s.width, s.height);
            
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(s.x + 12 + i * 40, s.y, 18, s.height);
            }
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üöö Âá∫Ëç∑Âè£', s.x + s.width/2, s.y + s.height/2 + 8);
        }

        function drawShelf(shelf) {
            const type = ITEM_TYPES[shelf.itemType];
            const order = game.currentOrder;
            const isNeeded = order && !order.readyToShip && 
                             order.items.some(item => item.type === shelf.itemType && item.collected < item.required);
            
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(shelf.x + 8, shelf.y + 8, shelf.width, shelf.height);

            ctx.fillStyle = '#5D4037';
            ctx.fillRect(shelf.x, shelf.y, shelf.width, shelf.height);
            
            ctx.fillStyle = '#795548';
            ctx.fillRect(shelf.x + 5, shelf.y + 5, shelf.width - 10, shelf.height - 5);
            
            ctx.fillStyle = '#A1887F';
            const boardYs = [shelf.y + 28, shelf.y + 55, shelf.y + 82];
            boardYs.forEach(by => {
                ctx.fillRect(shelf.x + 3, by - 2, shelf.width - 6, 5);
                ctx.fillStyle = '#6D4C41';
                ctx.fillRect(shelf.x + 3, by + 3, shelf.width - 6, 3);
                ctx.fillStyle = '#A1887F';
            });
            
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            const cols = [shelf.x + 25, shelf.x + 58, shelf.x + 91];
            const rows = [shelf.y + 26, shelf.y + 53, shelf.y + 80];
            
            rows.forEach(ry => {
                cols.forEach(cx => {
                    ctx.fillText(type.emoji, cx, ry);
                });
            });
            
            ctx.strokeStyle = isNeeded ? '#4CAF50' : '#3E2723';
            ctx.lineWidth = isNeeded ? 6 : 4;
            ctx.strokeRect(shelf.x, shelf.y, shelf.width, shelf.height);
            
            if (isNeeded) {
                const pulse = Math.sin(Date.now() / 200) * 0.1 + 0.2;
                ctx.fillStyle = `rgba(76, 175, 80, ${pulse})`;
                ctx.fillRect(shelf.x - 8, shelf.y - 8, shelf.width + 16, shelf.height + 16);
                
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ñº', shelf.x + shelf.width/2, shelf.y - 15);
            }
        }

        function drawForklift(fl) {
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(fl.x + 4, fl.y + 4, fl.width, fl.height);
            
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(fl.x, fl.y, fl.width, fl.height);
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(fl.x + 8, fl.y + 8, fl.width - 16, 20);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(fl.x + 5, fl.y + fl.height - 18, 12, 18);
            ctx.fillRect(fl.x + fl.width - 17, fl.y + fl.height - 18, 12, 18);
            
            ctx.font = '22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üöú', fl.x + fl.width/2, fl.y + fl.height/2 + 8);
        }

        function drawPlayer() {
            const blinkRate = game.hitCooldown > 0 ? 100 : 0;
            if (blinkRate && Math.floor(Date.now() / blinkRate) % 2 === 0) return;
            
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(player.x + player.width/2, player.y + player.height - 5, 
                        player.width/2 - 5, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(player.x + 8, player.y + 20, player.width - 16, player.height - 25);
            
            ctx.fillStyle = '#FFE4C4';
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, player.y + 15, 14, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#1a1a2e';
            const eyeOffset = player.direction === 'left' ? -3 : player.direction === 'right' ? 3 : 0;
            const eyeY = player.direction === 'up' ? 12 : 15;
            ctx.beginPath();
            ctx.arc(player.x + player.width/2 - 5 + eyeOffset, player.y + eyeY, 2, 0, Math.PI * 2);
            ctx.arc(player.x + player.width/2 + 5 + eyeOffset, player.y + eyeY, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(player.x + 4, player.y + 2, player.width - 8, 8);
            
            if (player.inventory.length > 0) {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(player.x + player.width - 5, player.y + 25, 18, 14);
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('üì¶', player.x + player.width + 4, player.y + 37);
            }
        }

        function drawUI() {
            ctx.fillStyle = 'rgba(26, 26, 46, 0.92)';
            ctx.fillRect(0, 0, SCREEN_WIDTH, 110);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(0, 108, SCREEN_WIDTH, 3);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('SCORE', 15, 28);
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(game.score.toLocaleString(), 15, 65);
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Lv.${game.level}   üì¶${game.completedOrders}‰ª∂`, 15, 90);

            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'right';
            const timeColor = game.timeLeft <= 10 ? '#FF5252' : game.timeLeft <= 20 ? '#FFA500' : '#4CAF50';
            ctx.fillStyle = timeColor;
            ctx.fillText('‚è±' + Math.ceil(game.timeLeft), SCREEN_WIDTH - 15, 50);
            
            if (game.timeLeft <= 10 && Math.floor(Date.now() / 300) % 2 === 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, SCREEN_WIDTH, 110);
            }

            drawOrder();
            drawActionHint();
        }

        function drawOrder() {
            const order = game.currentOrder;
            if (!order) return;

            const panelX = 150;
            const panelY = 8;
            
            const isUrgent = order.type === ORDER_TYPE.URGENT;
            ctx.fillStyle = isUrgent ? 'rgba(180, 50, 50, 0.9)' : 'rgba(60, 60, 80, 0.9)';
            
            const itemCount = order.items.length;
            const panelWidth = Math.min(80 + itemCount * 75, 550);
            ctx.fillRect(panelX, panelY, panelWidth, 95);
            ctx.strokeStyle = isUrgent ? '#FF5252' : '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelWidth, 95);

            ctx.fillStyle = isUrgent ? '#FF5252' : '#4CAF50';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            const label = isUrgent ? 'üö® Á∑äÊÄ•„Ç™„Éº„ÉÄ„Éº' : 'üìã ÈÄöÂ∏∏„Ç™„Éº„ÉÄ„Éº';
            ctx.fillText(label, panelX + 10, panelY + 20);
            
            const timeRatio = order.timeRemaining / order.timeLimit;
            const barWidth = 80;
            const barX = panelX + panelWidth - barWidth - 10;
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, panelY + 8, barWidth, 10);
            ctx.fillStyle = timeRatio > 0.5 ? '#4CAF50' : timeRatio > 0.25 ? '#FFA500' : '#FF5252';
            ctx.fillRect(barX, panelY + 8, barWidth * timeRatio, 10);
            
            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(`ÊÆã${Math.ceil(order.timeRemaining)}Áßí`, panelX + panelWidth - 12, panelY + 17);

            order.items.forEach((item, i) => {
                const ix = panelX + 15 + i * 70;
                const iy = panelY + 55;
                const type = ITEM_TYPES[item.type];
                const done = item.collected >= item.required;
                
                ctx.fillStyle = done ? 'rgba(76, 175, 80, 0.4)' : 'rgba(0,0,0,0.3)';
                ctx.fillRect(ix, iy - 22, 60, 55);
                
                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.globalAlpha = done ? 0.5 : 1;
                ctx.fillText(type.emoji, ix + 30, iy + 8);
                ctx.globalAlpha = 1;
                
                ctx.font = 'bold 14px sans-serif';
                ctx.fillStyle = done ? '#4CAF50' : '#fff';
                ctx.fillText(`${item.collected}/${item.required}`, ix + 30, iy + 28);
                
                if (done) {
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillText('‚úì', ix + 52, iy - 8);
                }
            });

            if (order.readyToShip) {
                ctx.fillStyle = 'rgba(76, 175, 80, 0.9)';
                ctx.fillRect(panelX + panelWidth + 10, panelY + 25, 100, 50);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('üöö Âá∫Ëç∑Ê∫ñÂÇô', panelX + panelWidth + 60, panelY + 45);
                ctx.fillText('ÂÆå‰∫ÜÔºÅ', panelX + panelWidth + 60, panelY + 65);
            }
        }

        function drawActionHint() {
            let hint = '';
            const order = game.currentOrder;
            
            if (order) {
                if (order.readyToShip && isNearShippingStation()) {
                    hint = 'üöö SPACE„ÅßÁ¥çÂìÅÔºÅ';
                } else if (!order.readyToShip) {
                    const shelf = findNearShelf();
                    if (shelf) {
                        const needed = order.items.find(item => 
                            item.type === shelf.itemType && item.collected < item.required);
                        if (needed) {
                            hint = `üì¶ SPACE„Åß ${ITEM_TYPES[shelf.itemType].emoji} „Çí„Éî„ÉÉ„ÇØÔºÅ`;
                        }
                    }
                }
            }
            
            if (hint) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(SCREEN_WIDTH/2 - 180, SCREEN_HEIGHT - 40, 360, 35);
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(hint, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 15);
            }
        }

        function drawEventLog() {
            const x = SCREEN_WIDTH - 220;
            let y = 130;
            
            game.eventLog.forEach((e, i) => {
                const alpha = Math.min(1, e.time);
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = e.type === 'urgent' ? 'rgba(255, 82, 82, 0.85)' :
                               e.type === 'warning' ? 'rgba(255, 165, 0, 0.85)' :
                               e.type === 'success' ? 'rgba(76, 175, 80, 0.85)' :
                               'rgba(60, 60, 80, 0.85)';
                ctx.fillRect(x, y, 210, 26);
                
                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(e.text, x + 8, y + 18);
                
                y += 30;
            });
            ctx.globalAlpha = 1;
        }

        function drawTelop() {
            if (!game.telopText) return;
            
            const alpha = Math.min(1, game.telopTimer);
            ctx.globalAlpha = alpha;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, SCREEN_HEIGHT / 2 - 45, SCREEN_WIDTH, 90);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(game.telopText, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 12);
            
            ctx.globalAlpha = 1;
        }

        function drawFlashEffect() {
            if (!game.flashEffect) return;
            
            const alpha = game.flashEffect.timer / game.flashEffect.duration;
            ctx.fillStyle = game.flashEffect.color;
            ctx.globalAlpha = alpha * 0.5;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            ctx.globalAlpha = 1;
        }

        function drawUrgentChoice() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            const urgent = game.pendingUrgent;
            if (!urgent) return;
            
            const panelW = 600;
            const panelH = 280;
            const panelX = SCREEN_WIDTH/2 - panelW/2;
            const panelY = 160;
            
            ctx.fillStyle = 'rgba(150, 30, 30, 0.95)';
            ctx.fillRect(panelX, panelY, panelW, panelH);
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 4;
            ctx.strokeRect(panelX, panelY, panelW, panelH);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üö® Á∑äÊÄ•„Ç™„Éº„ÉÄ„ÉºÂâ≤„ÇäËæº„ÅøÔºÅ', SCREEN_WIDTH/2, panelY + 45);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 22px sans-serif';
            ctx.fillText(`ÈÅ∏Êäû„Åæ„ÅßÊÆã„Çä ${Math.ceil(urgent.deadline)}Áßí`, SCREEN_WIDTH/2, panelY + 80);
            
            const itemStartX = SCREEN_WIDTH/2 - (urgent.items.length * 50);
            urgent.items.forEach((item, i) => {
                const type = ITEM_TYPES[item.type];
                const ix = itemStartX + i * 100;
                
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.arc(ix + 50, panelY + 140, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.font = '42px sans-serif';
                ctx.fillText(type.emoji, ix + 50, panelY + 155);
                ctx.font = 'bold 20px sans-serif';
                ctx.fillStyle = '#fff';
                ctx.fillText(`√ó${item.required}`, ix + 50, panelY + 195);
            });
            
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText('Y / Âèó„Åë„Çã„Éú„Çø„É≥ ‚Üí È´òÂæóÁÇπ ÔºÜ ÊôÇÈñì+10Áßí', SCREEN_WIDTH/2, panelY + 240);
            ctx.fillStyle = '#aaa';
            ctx.fillText('N / Á∂öË°å„Éú„Çø„É≥ ‚Üí Áèæ„Ç™„Éº„ÉÄ„ÉºÁ∂öË°åÔºà-5ÁßíÔºâ', SCREEN_WIDTH/2, panelY + 268);
        }

        function drawMinimap() {
            const mapX = SCREEN_WIDTH - 130;
            const mapY = SCREEN_HEIGHT - 130;
            const mapW = 120;
            const mapH = 115;
            const scaleX = mapW / MAP_WIDTH;
            const scaleY = mapH / MAP_HEIGHT;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(mapX - 5, mapY - 5, mapW + 10, mapH + 10);
            ctx.fillStyle = '#ddd';
            ctx.fillRect(mapX, mapY, mapW, mapH);

            ctx.fillStyle = '#8B4513';
            game.shelves.forEach(shelf => {
                ctx.fillRect(mapX + shelf.x * scaleX, mapY + shelf.y * scaleY,
                    Math.max(shelf.width * scaleX, 3), Math.max(shelf.height * scaleY, 3));
            });

            ctx.fillStyle = '#2E7D32';
            const s = game.shippingStation;
            ctx.fillRect(mapX + s.x * scaleX, mapY + s.y * scaleY, s.width * scaleX, s.height * scaleY);

            ctx.fillStyle = '#FF8C00';
            game.forklifts.forEach(fl => {
                ctx.fillRect(mapX + fl.x * scaleX - 2, mapY + fl.y * scaleY - 2, 5, 5);
            });

            const order = game.currentOrder;
            if (order && !order.readyToShip) {
                ctx.fillStyle = '#00FF00';
                game.shelves.forEach(shelf => {
                    const needed = order.items.some(item => 
                        item.type === shelf.itemType && item.collected < item.required);
                    if (needed) {
                        ctx.fillRect(mapX + shelf.x * scaleX - 2, mapY + shelf.y * scaleY - 2,
                            shelf.width * scaleX + 4, shelf.height * scaleY + 4);
                    }
                });
            }

            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(mapX + player.x * scaleX + 3, mapY + player.y * scaleY + 3, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 110, SCREEN_WIDTH, SCREEN_HEIGHT - 110);

            ctx.fillStyle = '#FF5252';
            ctx.font = 'bold 56px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('TIME UP!', SCREEN_WIDTH/2, 230);

            ctx.fillStyle = '#fff';
            ctx.font = '28px sans-serif';
            ctx.fillText('„Çπ„Ç≥„Ç¢: ' + game.score.toLocaleString(), SCREEN_WIDTH/2, 310);
            ctx.fillText(`ÂÆå‰∫Ü: ${game.completedOrders}‰ª∂ÔºàÁ∑äÊÄ•${game.urgentCompleted}‰ª∂Ôºâ`, SCREEN_WIDTH/2, 355);
            ctx.fillText('Âà∞ÈÅî„É¨„Éô„É´: ' + game.level, SCREEN_WIDTH/2, 400);
            
            if (game.urgentMissed > 0) {
                ctx.fillStyle = '#FF6B6B';
                ctx.font = '20px sans-serif';
                ctx.fillText(`Á∑äÊÄ•ÊãíÂê¶: ${game.urgentMissed}Âõû`, SCREEN_WIDTH/2, 440);
            }

            let rank = 'ü•â „Éñ„É≠„É≥„Ç∫';
            let rankColor = '#CD7F32';
            if (game.score >= 35000) { rank = 'üèÜ „Éû„Çπ„Çø„Éº'; rankColor = '#FFD700'; }
            else if (game.score >= 25000) { rank = 'ü•á „Ç¥„Éº„É´„Éâ'; rankColor = '#FFD700'; }
            else if (game.score >= 15000) { rank = 'ü•à „Ç∑„É´„Éê„Éº'; rankColor = '#C0C0C0'; }
            
            ctx.fillStyle = rankColor;
            ctx.font = 'bold 40px sans-serif';
            ctx.fillText(rank, SCREEN_WIDTH/2, 510);

            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 28px sans-serif';
                ctx.fillText('üéÆ SPACE / „Çø„ÉÉ„Éó „Åß„É™„Éà„É©„Ç§ üéÆ', SCREEN_WIDTH/2, 620);
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - game.lastTime) / 1000;
            game.lastTime = timestamp;
            update(Math.min(deltaTime, 0.1));
            draw();
            requestAnimationFrame(gameLoop);
        }

        generateMap();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>